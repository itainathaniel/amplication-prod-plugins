"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Interface = void 0;
const ClassReference_1 = require("./ClassReference");
const AstNode_1 = require("../core/AstNode");
const Method_1 = require("./Method");
class Interface extends AstNode_1.AstNode {
    name;
    namespace;
    access;
    partial;
    reference;
    isNestedInterface;
    fields = [];
    methods = [];
    constructor({ name, namespace, access, partial, isNestedInterface, }) {
        super();
        this.name = name;
        this.namespace = namespace;
        this.access = access;
        this.partial = partial ?? false;
        this.isNestedInterface = isNestedInterface ?? false;
        this.reference = new ClassReference_1.ClassReference({
            name: this.name,
            namespace: this.namespace,
        });
    }
    addField(field) {
        this.fields.push(field);
    }
    addMethod(method) {
        method.classType = Method_1.MethodClassType.INTERFACE;
        this.methods.push(method);
    }
    write(writer) {
        if (!this.isNestedInterface) {
            writer.writeLine(`namespace ${this.namespace};`);
            writer.newLine();
        }
        writer.write(`${this.access} `);
        if (this.partial) {
            writer.write("partial ");
        }
        writer.write("interface ");
        writer.writeLine(`${this.name}`);
        writer.writeLine("{");
        writer.indent();
        for (const field of this.fields) {
            field.write(writer);
            writer.writeLine("");
        }
        writer.dedent();
        writer.indent();
        for (const method of this.methods) {
            method.write(writer);
            writer.writeLine("");
        }
        writer.dedent();
        writer.writeLine("}");
    }
    getMethods() {
        return this.methods;
    }
}
exports.Interface = Interface;
//# sourceMappingURL=Interface.js.map