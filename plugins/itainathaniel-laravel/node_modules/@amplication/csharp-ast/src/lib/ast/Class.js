"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Class = void 0;
const Access_1 = require("./Access");
const ClassReference_1 = require("./ClassReference");
const AstNode_1 = require("../core/AstNode");
class Class extends AstNode_1.AstNode {
    name;
    namespace;
    access;
    abstract;
    static_;
    sealed;
    partial;
    reference;
    interfaceReferences;
    isNestedClass;
    annotations = [];
    splitAnnotations;
    fields = [];
    constructors = [];
    methods = [];
    nestedClasses = [];
    nestedInterfaces = [];
    parentClassReference;
    constructor({ name, namespace, access, abstract, static_, sealed, partial, parentClassReference, interfaceReferences, isNestedClass, annotations, splitAnnotations, }) {
        super();
        this.name = name;
        this.namespace = namespace;
        this.access = access;
        this.abstract = abstract ?? false;
        this.static_ = static_ ?? false;
        this.sealed = sealed ?? false;
        this.partial = partial ?? false;
        this.isNestedClass = isNestedClass ?? false;
        this.annotations = annotations ?? [];
        this.splitAnnotations = splitAnnotations ?? true;
        this.parentClassReference = parentClassReference;
        this.interfaceReferences = interfaceReferences ?? [];
        this.reference = new ClassReference_1.ClassReference({
            name: this.name,
            namespace: this.namespace,
        });
    }
    addField(field) {
        this.fields.push(field);
    }
    addConstructor(constructor) {
        this.constructors.push(constructor);
    }
    addMethod(method) {
        this.methods.push(method);
    }
    addNestedClass(subClass) {
        this.nestedClasses.push(subClass);
    }
    addNestedInterface(subInterface) {
        this.nestedInterfaces.push(subInterface);
    }
    write(writer) {
        if (!this.isNestedClass) {
            writer.writeLine(`namespace ${this.namespace};`);
            writer.newLine();
        }
        if (this.annotations.length > 0) {
            !this.splitAnnotations && writer.write("[");
            this.annotations.forEach((annotation, index) => {
                if (this.splitAnnotations) {
                    writer.write("[");
                    annotation.write(writer);
                    writer.write("]");
                    writer.newLine();
                }
                else {
                    annotation.write(writer);
                    if (index < this.annotations.length - 1) {
                        writer.write(", ");
                    }
                }
            });
            !this.splitAnnotations && writer.write("]");
            writer.writeNewLineIfLastLineNot();
        }
        writer.write(`${this.access}`);
        if ([this.abstract, this.sealed, this.static_].filter((x) => x).length > 1) {
            throw new Error("A class can only be one of abstract, sealed, or static at a time");
        }
        if (this.abstract) {
            writer.write(" abstract");
        }
        if (this.sealed) {
            writer.write(" sealed");
        }
        if (this.static_) {
            writer.write(" static");
        }
        if (this.partial) {
            writer.write(" partial");
        }
        writer.write(" class");
        writer.write(` ${this.name}`);
        if (this.parentClassReference != null ||
            this.interfaceReferences.length > 0) {
            writer.write(" : ");
            if (this.parentClassReference != null) {
                this.parentClassReference.write(writer);
                if (this.interfaceReferences.length > 0) {
                    writer.write(", ");
                }
            }
            this.interfaceReferences.forEach((interfaceReference, index) => {
                interfaceReference.write(writer);
                // Don't write a comma after the last interface
                if (index < this.interfaceReferences.length - 1) {
                    writer.write(", ");
                }
            });
        }
        writer.writeNewLineIfLastLineNot();
        writer.writeLine("{");
        writer.indent();
        this.writeFields({
            writer,
            fields: this.getFieldsByAccess(Access_1.Access.Private),
        });
        writer.dedent();
        writer.indent();
        this.writeFields({
            writer,
            fields: this.getFieldsByAccess(Access_1.Access.Protected),
        });
        writer.dedent();
        writer.indent();
        this.writeConstructors({ writer, constructors: this.constructors });
        writer.dedent();
        writer.indent();
        this.writeFields({ writer, fields: this.getFieldsByAccess(Access_1.Access.Public) });
        writer.dedent();
        writer.indent();
        this.nestedClasses.forEach((nestedClass, index) => {
            nestedClass.write(writer);
            writer.writeNewLineIfLastLineNot();
            if (index < this.fields.length - 1) {
                writer.newLine();
            }
        });
        writer.dedent();
        writer.indent();
        this.nestedInterfaces.forEach((nestedInterface, index) => {
            nestedInterface.write(writer);
            writer.writeNewLineIfLastLineNot();
            if (index < this.fields.length - 1) {
                writer.newLine();
            }
        });
        writer.dedent();
        writer.indent();
        this.writeMethods({
            writer,
            methods: this.getMethodsByAccess(Access_1.Access.Public),
        });
        writer.dedent();
        writer.indent();
        this.writeMethods({
            writer,
            methods: this.getMethodsByAccess(Access_1.Access.Private),
        });
        writer.dedent();
        writer.writeLine("}");
    }
    writeConstructors({ writer, constructors, }) {
        constructors.forEach((constructor, index) => {
            writer.write(`${constructor.access} ${this.name} (`);
            constructor.parameters.forEach((parameter, index) => {
                parameter.write(writer);
                if (index < constructor.parameters.length - 1) {
                    writer.write(", ");
                }
            });
            writer.write(")");
            if (constructor.bases && constructor.bases.length > 0) {
                const bases = constructor.bases;
                writer.write(": base(");
                bases.forEach((base, index) => {
                    writer.write(base);
                    if (index < bases.length - 1) {
                        writer.write(", ");
                    }
                });
                writer.write(")");
            }
            writer.writeLine(" {");
            writer.indent();
            constructor.body?.write(writer);
            writer.dedent();
            writer.writeLine("}");
            writer.newLine();
        });
    }
    writeMethods({ writer, methods, }) {
        methods.forEach((method, index) => {
            method.write(writer);
            writer.writeNewLineIfLastLineNot();
            writer.newLine();
        });
    }
    getMethodsByAccess(access) {
        return this.methods.filter((method) => method.access === access);
    }
    writeFields({ writer, fields, }) {
        fields.forEach((field, index) => {
            field.write(writer);
            writer.writeNewLineIfLastLineNot();
            if (index < this.fields.length - 1) {
                writer.newLine();
            }
        });
    }
    getFieldsByAccess(access) {
        return this.fields.filter((field) => field.access === access);
    }
    getFields() {
        return this.fields;
    }
    getMethods() {
        return this.methods;
    }
}
exports.Class = Class;
//# sourceMappingURL=Class.js.map