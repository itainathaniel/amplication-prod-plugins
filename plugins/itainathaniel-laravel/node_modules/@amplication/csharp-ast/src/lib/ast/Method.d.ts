import { Access } from "./Access";
import { ClassReference } from "./ClassReference";
import { CodeBlock } from "./CodeBlock";
import { AstNode } from "../core/AstNode";
import { Writer } from "../core/Writer";
import { MethodInvocation } from "./MethodInvocation";
import { Parameter } from "./Parameter";
import { Type } from "./Type";
import { Annotation } from "./Annotation";
export declare enum MethodType {
    INSTANCE = 0,
    STATIC = 1
}
export declare enum MethodClassType {
    CLASS = 0,
    INTERFACE = 1
}
export declare namespace Method {
    interface Args {
        name: string;
        access: Access;
        isAsync: boolean;
        parameters: Parameter[];
        return_?: Type;
        body?: CodeBlock;
        summary?: string;
        type?: MethodType;
        classReference?: ClassReference;
        extensionParameter?: Parameter;
        annotations?: Annotation[];
        splitAnnotations?: boolean;
    }
}
export declare class Method extends AstNode {
    readonly name: string;
    readonly isAsync: boolean;
    readonly access: Access;
    readonly return: Type | undefined;
    readonly body: CodeBlock | undefined;
    readonly summary: string | undefined;
    readonly type: MethodType;
    readonly reference: ClassReference | undefined;
    classType: MethodClassType;
    private parameters;
    private extensionParameter?;
    readonly annotations?: Annotation[];
    readonly splitAnnotations?: boolean;
    constructor({ name, isAsync, access, return_, body, summary, type, classReference, parameters, extensionParameter, annotations, splitAnnotations, }: Method.Args);
    addParameter(parameter: Parameter): void;
    write(writer: Writer): void;
    getParameters(): Parameter[];
    getInvocation(args: Map<Parameter, CodeBlock>, on?: CodeBlock): MethodInvocation;
    getInvocationFromExample(example: Map<string, unknown>, on?: CodeBlock): MethodInvocation;
}
