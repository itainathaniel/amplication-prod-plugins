"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Writer = void 0;
const TAB_SIZE = 4;
class Writer {
    /* The contents being written */
    buffer = "";
    /* Indentation level (multiple of 4) */
    indentLevel = 0;
    /* Whether anything has been written to the buffer */
    hasWrittenAnything = false;
    /* Whether the last character written was a newline */
    lastCharacterIsNewline = false;
    /* The current line number */
    references = {};
    /* The namespace that is being written to */
    namespace;
    constructor({ namespace }) {
        this.namespace = namespace;
    }
    write(text) {
        const textEndsInNewline = text.length > 0 && text.endsWith("\n");
        // temporarily remove the trailing newline, since we don't want to add the indent prefix after it
        const textWithoutNewline = textEndsInNewline
            ? text.substring(0, text.length - 1)
            : text;
        const indent = this.getIndentString();
        let indentedText = textWithoutNewline.replace("\n", `\n${indent}`);
        if (this.isAtStartOfLine()) {
            indentedText = indent + indentedText;
        }
        if (textEndsInNewline) {
            indentedText += "\n";
        }
        this.writeInternal(indentedText);
    }
    writeNode(node) {
        node.write(this);
    }
    /* Only writes a newline if last line in the buffer is not a newline */
    writeLine(text = "") {
        this.write(text);
        this.writeNewLineIfLastLineNot();
    }
    /* Always writes newline */
    newLine() {
        this.writeInternal("\n");
    }
    writeNewLineIfLastLineNot() {
        if (!this.lastCharacterIsNewline) {
            this.writeInternal("\n");
        }
    }
    indent() {
        this.indentLevel++;
    }
    dedent() {
        this.indentLevel--;
    }
    addReference(reference) {
        if (reference.namespace == null) {
            return;
        }
        const namespace = this.references[reference.namespace];
        if (namespace != null) {
            namespace.push(reference);
        }
        else {
            this.references[reference.namespace] = [reference];
        }
    }
    toString() {
        const imports = this.stringifyImports();
        if (imports.length > 0) {
            return `${imports}\n\n${this.buffer}`;
        }
        return this.buffer;
    }
    /*******************************
     * Helper Methods
     *******************************/
    writeInternal(text) {
        if (text.length > 0) {
            this.hasWrittenAnything = true;
            this.lastCharacterIsNewline = text.endsWith("\n");
        }
        return (this.buffer += text);
    }
    isAtStartOfLine() {
        return this.lastCharacterIsNewline || !this.hasWrittenAnything;
    }
    getIndentString() {
        return " ".repeat(this.indentLevel * TAB_SIZE);
    }
    stringifyImports() {
        return (Object.keys(this.references)
            // filter out the current namespace
            .filter((referenceNamespace) => referenceNamespace !== this.namespace)
            .map((ref) => `using ${ref};`)
            .join("\n"));
    }
}
exports.Writer = Writer;
//# sourceMappingURL=Writer.js.map