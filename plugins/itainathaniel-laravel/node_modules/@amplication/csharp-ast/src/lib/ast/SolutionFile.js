"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Solution = void 0;
const AstNode_1 = require("../core/AstNode");
class Solution extends AstNode_1.AstNode {
    projects = [];
    solutionConfigurations = [];
    projectConfigurations = [];
    dependencies = new Map();
    solutionVersion = "";
    visualStudioVersion = "";
    minimumVisualStudioVersion = "";
    constructor() {
        super();
    }
    /**
     * Parses an existing solution file and loads metadata, projects, configurations, and dependencies.
     */
    parse(content) {
        const lines = content.split("\n");
        let currentSection = null;
        for (let line of lines) {
            line = line.trim();
            // Parse Minimum Visual Studio version
            const minVSVersionMatch = /MinimumVisualStudioVersion = (.+)/.exec(line);
            if (minVSVersionMatch) {
                this.minimumVisualStudioVersion = minVSVersionMatch[1];
                continue;
            }
            // Parse solution version
            const versionMatch = /Microsoft Visual Studio Solution File, Format Version (.+)/.exec(line);
            if (versionMatch) {
                this.solutionVersion = versionMatch[1];
                continue;
            }
            // Parse Visual Studio version
            const vsVersionMatch = /VisualStudioVersion = (.+)/.exec(line);
            if (vsVersionMatch) {
                this.visualStudioVersion = vsVersionMatch[1];
                continue;
            }
            // Parse projects
            const projectMatch = /Project\("(.+?)"\) = "(.+?)", "(.+?)", "(.+?)"/.exec(line);
            if (projectMatch) {
                const [, typeGUID, name, path, projectGUID] = projectMatch;
                this.projects.push({ name, path, typeGUID, projectGUID });
                continue;
            }
            // Detect global sections
            const sectionStartMatch = /GlobalSection\((.+?)\) = .+/.exec(line);
            if (sectionStartMatch) {
                currentSection = sectionStartMatch[1];
                continue;
            }
            // Process solution configurations
            if (currentSection === "SolutionConfigurationPlatforms") {
                const configMatch = /(.+?)\|(.+?) =/.exec(line);
                if (configMatch) {
                    const [, name, platform] = configMatch;
                    this.solutionConfigurations.push({ name, platform });
                }
            }
            // Process project configurations
            if (currentSection === "ProjectConfigurationPlatforms") {
                const projectConfigMatch = /({[\w-]+}|\w+)\.(\w+)\|([\w\s]+)\.(ActiveCfg|Build\.0) = ([\w\s|]+)/.exec(line);
                if (projectConfigMatch) {
                    const [, projectID, config, platform, type, activeCfg] = projectConfigMatch;
                    const isBuild = type === "Build.0";
                    this.projectConfigurations.push({
                        projectGUID: projectID,
                        activeCfg: `${config}|${platform}`,
                        build: isBuild,
                    });
                }
            }
            // Process project dependencies
            if (currentSection === "ProjectDependencies") {
                const depMatch = /({.+?}) = ({.+?})/.exec(line);
                if (depMatch) {
                    const [, projectGUID, dependentGUID] = depMatch;
                    if (!this.dependencies.has(projectGUID)) {
                        this.dependencies.set(projectGUID, []);
                    }
                    this.dependencies.get(projectGUID)?.push(dependentGUID);
                }
            }
            // End of section
            if (line.startsWith("EndGlobalSection")) {
                currentSection = null;
            }
        }
    }
    /**
     * Adds a new project to the solution.
     */
    addProject(name, path, typeGUID, projectGUID, dependencies = []) {
        this.projects.push({ name, path, typeGUID, projectGUID });
        // Add dependencies
        if (dependencies.length > 0) {
            this.dependencies.set(projectGUID, dependencies);
        }
        // Add default project configurations
        this.solutionConfigurations.forEach((config) => {
            this.projectConfigurations.push({
                projectGUID,
                activeCfg: `${config.name}|Any CPU`,
                build: true,
            });
        });
        return projectGUID;
    }
    /**
     * Removes a project from the solution.
     */
    removeProject(name) {
        const project = this.projects.find((p) => p.name === name);
        if (!project)
            return;
        // Remove project and its configurations
        this.projects = this.projects.filter((p) => p.name !== name);
        this.projectConfigurations = this.projectConfigurations.filter((pc) => pc.projectGUID !== project.projectGUID);
        this.dependencies.delete(project.projectGUID);
    }
    /**
     * Sorts projects while respecting dependencies.
     */
    sortProjects() {
        const sorted = [];
        const visited = new Set();
        const visit = (project) => {
            if (visited.has(project.projectGUID))
                return;
            visited.add(project.projectGUID);
            const deps = this.dependencies.get(project.projectGUID) || [];
            deps.forEach((depGUID) => {
                const depProject = this.projects.find((p) => p.projectGUID === depGUID);
                if (depProject)
                    visit(depProject);
            });
            sorted.push(project);
        };
        this.projects.forEach(visit);
        this.projects = sorted;
    }
    /**
     * Generates the updated `.sln` file content.
     */
    write(writer) {
        this.sortProjects(); // Ensure projects are sorted before writing
        writer.writeLine(`Microsoft Visual Studio Solution File, Format Version ${this.solutionVersion}`);
        writer.writeLine(`# Visual Studio Version 17`);
        writer.writeLine(`VisualStudioVersion = ${this.visualStudioVersion}`);
        writer.writeLine(`MinimumVisualStudioVersion = ${this.minimumVisualStudioVersion}`);
        // Write sorted project entries
        this.projects.forEach((project) => {
            writer.writeLine(`Project("${project.typeGUID}") = "${project.name}", "${project.path}", "${project.projectGUID}"`);
            writer.writeLine(`EndProject`);
        });
        // Global settings
        writer.writeLine(`Global`);
        //writer.indent();
        // Solution Configurations
        writer.writeLine(`\tGlobalSection(SolutionConfigurationPlatforms) = preSolution`);
        this.solutionConfigurations.forEach(({ name, platform }) => {
            writer.writeLine(`\t\t${name}|${platform} = ${name}|${platform}`);
        });
        writer.writeLine(`\tEndGlobalSection`);
        // Project Configurations
        writer.writeLine(`\tGlobalSection(ProjectConfigurationPlatforms) = postSolution`);
        this.projectConfigurations.forEach(({ projectGUID, activeCfg, build }) => {
            if (build) {
                writer.writeLine(`\t\t${projectGUID}.${activeCfg}.Build.0 = ${activeCfg}`);
            }
            else {
                writer.writeLine(`\t\t${projectGUID}.${activeCfg}.ActiveCfg = ${activeCfg}`);
            }
        });
        writer.writeLine(`\tEndGlobalSection`);
        // Project Dependencies
        if (this.dependencies.size > 0) {
            writer.writeLine(`\tGlobalSection(ProjectDependencies) = postSolution`);
            this.dependencies.forEach((deps, projectGUID) => {
                deps.forEach((depGUID) => {
                    writer.writeLine(`\t\t${projectGUID} = ${depGUID}`);
                });
            });
            writer.writeLine(`\tEndGlobalSection`);
        }
        writer.writeLine(`\tGlobalSection(SolutionProperties) = preSolution`);
        writer.writeLine(`\t\tHideSolutionNode = FALSE`);
        writer.writeLine(`\tEndGlobalSection`);
        //writer.dedent();
        writer.writeLine(`EndGlobal`);
    }
}
exports.Solution = Solution;
//# sourceMappingURL=SolutionFile.js.map