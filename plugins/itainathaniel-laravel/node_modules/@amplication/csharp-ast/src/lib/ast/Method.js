"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Method = exports.MethodClassType = exports.MethodType = void 0;
const AstNode_1 = require("../core/AstNode");
const MethodInvocation_1 = require("./MethodInvocation");
var MethodType;
(function (MethodType) {
    MethodType[MethodType["INSTANCE"] = 0] = "INSTANCE";
    MethodType[MethodType["STATIC"] = 1] = "STATIC";
})(MethodType || (exports.MethodType = MethodType = {}));
var MethodClassType;
(function (MethodClassType) {
    MethodClassType[MethodClassType["CLASS"] = 0] = "CLASS";
    MethodClassType[MethodClassType["INTERFACE"] = 1] = "INTERFACE";
})(MethodClassType || (exports.MethodClassType = MethodClassType = {}));
class Method extends AstNode_1.AstNode {
    name;
    isAsync;
    access;
    return;
    body;
    summary;
    type;
    reference;
    classType = MethodClassType.CLASS;
    parameters;
    extensionParameter;
    annotations;
    splitAnnotations;
    constructor({ name, isAsync, access, return_, body, summary, type, classReference, parameters, extensionParameter, annotations, splitAnnotations, }) {
        super();
        this.name = name;
        this.isAsync = isAsync;
        this.access = access;
        this.return = return_;
        this.body = body;
        this.summary = summary;
        this.type = type ?? MethodType.INSTANCE;
        this.reference = classReference;
        this.parameters = parameters;
        this.extensionParameter = extensionParameter;
        this.annotations = annotations ?? [];
        this.splitAnnotations = splitAnnotations ?? true;
    }
    addParameter(parameter) {
        this.parameters.push(parameter);
    }
    write(writer) {
        if (this.summary != null) {
            writer.writeLine("/// <summary>");
            this.summary.split("\n").forEach((line) => {
                writer.writeLine(`/// ${line}`);
            });
            writer.writeLine("/// </summary>");
        }
        if (this.annotations && this.annotations.length > 0) {
            !this.splitAnnotations && writer.write("[");
            this.annotations.forEach((annotation, index) => {
                if (this.splitAnnotations) {
                    writer.write("[");
                    annotation.write(writer);
                    writer.write("]");
                    writer.newLine();
                }
                else {
                    annotation.write(writer);
                    if (index < (this.annotations ? this.annotations.length : 0) - 1) {
                        writer.write(", ");
                    }
                }
            });
            !this.splitAnnotations && writer.write("]");
            writer.writeNewLineIfLastLineNot();
        }
        writer.write(`${this.access} `);
        if (this.type === MethodType.STATIC) {
            writer.write("static ");
        }
        if (this.isAsync && this.classType !== MethodClassType.INTERFACE) {
            writer.write("async ");
        }
        if (this.return == null) {
            const voidReturn = this.isAsync ? "Task" : "void";
            writer.write(voidReturn);
            writer.write(" ");
        }
        else {
            if (!this.isAsync) {
                this.return.write(writer);
            }
            else {
                writer.write("Task<");
                this.return.write(writer);
                writer.write(">");
            }
            writer.write(" ");
        }
        writer.write(`${this.name}(`);
        if (this.extensionParameter) {
            writer.write("this ");
            this.extensionParameter.write(writer);
            this.parameters?.length > 0 && writer.write(", ");
        }
        this.parameters.forEach((parameter, idx) => {
            parameter.write(writer);
            if (idx < this.parameters.length - 1) {
                writer.write(", ");
            }
        });
        writer.write(")");
        if (this.classType === MethodClassType.INTERFACE) {
            writer.write(";");
        }
        else {
            writer.writeLine(" {");
            writer.indent();
            this.body?.write(writer);
            writer.dedent();
            writer.writeLine("}");
        }
    }
    getParameters() {
        return this.parameters;
    }
    getInvocation(args, on) {
        return new MethodInvocation_1.MethodInvocation({
            method: this,
            arguments_: args,
            on,
        });
    }
    getInvocationFromExample(example, on) {
        const args = new Map();
        for (const parameter of this.parameters) {
            const value = example.get(parameter.name);
            if (value !== undefined) {
                // TODO: actually handle these examples
                // args.set(parameter, new CodeBlock({ value: value as string }));
            }
        }
        return new MethodInvocation_1.MethodInvocation({
            method: this,
            arguments_: args,
            on,
        });
    }
}
exports.Method = Method;
//# sourceMappingURL=Method.js.map