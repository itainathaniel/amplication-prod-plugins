"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Type = void 0;
const assertNever_1 = require("../utils/assertNever");
const ClassReference_1 = require("./ClassReference");
const AstNode_1 = require("../core/AstNode");
/* A C# parameter to a method */
class Type extends AstNode_1.AstNode {
    internalType;
    constructor(internalType) {
        super();
        this.internalType = internalType;
    }
    write(writer) {
        switch (this.internalType.type) {
            case "integer":
                writer.write("int");
                break;
            case "long":
                writer.write("long");
                break;
            case "string":
                writer.write("string");
                break;
            case "boolean":
                writer.write("bool");
                break;
            case "double":
                writer.write("double");
                break;
            case "date":
                writer.write("DateOnly");
                break;
            case "dateTime":
                writer.write("DateTime");
                break;
            case "uuid":
                writer.write("Guid");
                break;
            case "object":
                writer.write("object");
                break;
            case "list":
                writer.write("List<");
                this.internalType.value.write(writer);
                writer.write(">");
                break;
            case "set":
                writer.write("HashSet<");
                this.internalType.value.write(writer);
                writer.write(">");
                break;
            case "map":
                writer.write("Dictionary<");
                this.internalType.keyType.write(writer);
                writer.write(", ");
                this.internalType.valueType.write(writer);
                writer.write(">");
                break;
            case "optional":
                this.internalType.value.write(writer);
                writer.write("?");
                break;
            case "reference":
                writer.addReference(this.internalType.value);
                writer.write(this.internalType.value.name);
                break;
            case "coreReference":
                writer.write(this.internalType.value.name);
                break;
            case "genericReference":
                this.internalType.value.write(writer);
                break;
            case "oneOf":
                writer.addReference(ClassReference_1.OneOfClassReference);
                writer.write("OneOf<");
                this.internalType.memberValues.forEach((value, index) => {
                    if (index !== 0) {
                        writer.write(", ");
                    }
                    value.write(writer);
                });
                writer.write(">");
                break;
            case "stringEnum":
                writer.addReference(ClassReference_1.StringEnumClassReference);
                writer.write("StringEnum<");
                this.internalType.value.write(writer);
                writer.write(">");
                break;
            default:
                (0, assertNever_1.assertNever)(this.internalType);
        }
    }
    /* Static factory methods for creating a Type */
    static string() {
        return new this({
            type: "string",
        });
    }
    static boolean() {
        return new this({
            type: "boolean",
        });
    }
    static integer() {
        return new this({
            type: "integer",
        });
    }
    static long() {
        return new this({
            type: "long",
        });
    }
    static double() {
        return new this({
            type: "double",
        });
    }
    static date() {
        return new this({
            type: "date",
        });
    }
    static dateTime() {
        return new this({
            type: "dateTime",
        });
    }
    static uuid() {
        return new this({
            type: "uuid",
        });
    }
    static object() {
        return new this({
            type: "object",
        });
    }
    static list(value) {
        return new this({
            type: "list",
            value,
        });
    }
    static set(value) {
        return new this({
            type: "set",
            value,
        });
    }
    static map(keyType, valueType) {
        return new this({
            type: "map",
            keyType,
            valueType,
        });
    }
    static optional(value) {
        return new this({
            type: "optional",
            value,
        });
    }
    static reference(value) {
        return new this({
            type: "reference",
            value,
        });
    }
    static genericReference(value) {
        return new this({
            type: "genericReference",
            value,
        });
    }
    static coreClass(value) {
        return new this({
            type: "coreReference",
            value,
        });
    }
    static oneOf(memberValues) {
        return new this({
            type: "oneOf",
            memberValues,
        });
    }
    static stringEnum(value) {
        return new this({
            type: "stringEnum",
            value,
        });
    }
}
exports.Type = Type;
//# sourceMappingURL=Type.js.map